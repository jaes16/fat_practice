#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <libgen.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <math.h>




/////////////////////////////////////////////////////// SIZES //////////////////////////////////////////////////////
#define DISK_SIZE 10485759
#define BLOCK_SIZE 4096
#define CLUSTER_TOTALNUM 2560
#define ENDOFFILE 3000
#define FREE 4000
#define PATH_MAX 4096 //unix definition.
#define COM_LENGTH 4100

// errors
#define ENOTPERM 1 //operation not permitted
#define ENOENT 2 //no such file or directory
#define EACCES 13 //permission denied
#define EEXIST 17 //file already exists
#define ENOTDIR 20 //not a directory
#define EISDIR 21 //is a directory
#define ENOSPC 28 //no more space
#define EMLINK 31 //too many links
#define ENAMETOOLONG 36 //file name too long
#define ENOTEMPTY 39 //directory not empty
#define ELOOP 40 //too many links

#define ECOMMAND -1 //command in the wrong format. My own shtuf


/////////////////////////////////////////////////////// DEFINITION OF DATA STRUCTURES  /////////////////////////////
struct fat_superblock
{
  // if uninitialized                                                                                          
  int fat_location;
  int fat_size;
  int data_location; //root dir first cluster location                                                         
  int data_size;
  //  int freelist_location; //essentially pointer to the first free cluster                                   
};

union {
  struct fat_superblock s;
  char pad[BLOCK_SIZE];
} superblock;


typedef struct
{
  int cur;
  struct free_node *next;
}free_node;

typedef struct
{
  int first_cluster;
  int file_size; // in bytes                                                                                   
  int dir_type; // 0 for empty, 1 for directory, 2 for file                                                    
  mode_t mode; // 0 for read and write, 1 for read only                                                      
  char name[32];
}dir_entry;




/////////////////////////////////////////////////////// GLOBAL VARIABLES ////////////////////////////////////////////////////////
char disk_path[1024];
FILE *disk;
int fd_disk;


int fat[3072];


int last_free = 0;

char rootdir[PATH_MAX];
char workdir[PATH_MAX];
int workdir_clusternum;





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////// CODE ///////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////









// When theres no disk, create generic disk                                                                                            
void create_init_disk()
{
  // write out superblock                                                                                                              
  fd_disk = fileno(disk);
  pwrite(fd_disk,&superblock,BLOCK_SIZE,0);

  // write out fat                                                                                                                     
  memset(&fat,0,sizeof(fat));
  for(int i = 0; i < 2556; i++){
    // fill buffers with value for free
    fat[i] = FREE;
  }
  //make sure root dir cluster is allocated                                                                                            
  fat[0] = ENDOFFILE;

  pwrite(fd_disk,fat,(sizeof(int)*3072),BLOCK_SIZE);


  // write out root dir                
  dir_entry dir_entries[4096]; //rather arbitrary size, but point is its bigger than block size 
  memset(dir_entries, 0, sizeof(dir_entries));
  //creating . 
  dir_entries[0].first_cluster = 4;
  dir_entries[0].file_size = 2;
  dir_entries[0].dir_type = 1;
  dir_entries[0].mode = S_IFDIR | 0755;
  memset(dir_entries[0].name,0,32);
  strcpy(dir_entries[0].name,".");
  // creating .. 
  dir_entries[1].first_cluster = 4;
  dir_entries[1].file_size = 2;
  dir_entries[1].dir_type = 1;
  dir_entries[1].mode = S_IFDIR | 0755;
  memset(dir_entries[1].name,0,32);
  strcpy(dir_entries[1].name,"..");
  pwrite(fd_disk, &dir_entries, 4096, (4*4096));

}





static void* fat_init()
{
  // find where "disk" file should be 
  memset(disk_path, '\0', sizeof(disk_path));
  getcwd(disk_path, sizeof(disk_path));
  strcat(disk_path, "/fat_disk");

  // see if "disk" file is initialized  
  if((disk = fopen(disk_path, "r+"))){
    // if it is, read in superblock   
    fd_disk = fileno(disk);
    pread(fd_disk,&superblock,sizeof(superblock),0);

    pread(fd_disk,&fat, sizeof(fat),BLOCK_SIZE);

  }else{
    // if it isn't, create file and write out initial superblock 
    disk = fopen(disk_path, "w+");
    fseek(disk, DISK_SIZE, SEEK_SET);
    fputc('\0', disk);

    // initial locations for fat and data 
    superblock.s.fat_location = 1;
    superblock.s.fat_size = 3;
    superblock.s.data_location = 4;
    superblock.s.data_size = 2556;
    // superblock.s.freelist_location = 5;

    // write out initialized disk  
    create_init_disk();

  }
  
  // set root and working directories
  memset(rootdir,0,PATH_MAX);
  memset(workdir,0,PATH_MAX);
  strcpy(rootdir,"/");
  strncpy(workdir,rootdir,PATH_MAX);
  workdir_clusternum = 4;
  return NULL;
}




int helper(char *path, char *ret){
  memset(ret,0,32);
  char *ptr = strchr(path, '/');
  if(ptr) {
    int index = ptr - path;
    if (index > 32) return -2;

    strncpy(ret,path,index);
    return index+1;
  }else{ return -1;}
  return 0;
}




// return 0 if path exists, -1 if path doesn't exist, -2 if path name is too long, -3 if component of path is file
// later, can remove last and just find it from path in this function
static int dir_exists(char *path, int cluster_num, dir_entry *de, char *last)
{

  // bring in all the dir entries 
  dir_entry dir_entries[4096];//[((4096/sizeof(dir_entries)) + 1)]; 
  memset(dir_entries, 0, sizeof(dir_entries));
  pread(fd_disk, &dir_entries, 4096, (4096*cluster_num));


  // name of the next directory in path to look for
  //char* token = strtok(path, "/");
  char token[32];
  int index;
  // helper returns wrong result when path = token, so
  if((strcmp(path,last) != 0) && (strlen(path) != strlen(last))){
    index = helper(path,token);
    // if name is too long 
    if(index == -2) return -2;
    // should never return -1, but... 
    if(index == -1) return -1;
  } else {

    strcpy(token,path);
  }
  int isFile = 0;
  //search through dir_entries in current directory to see if the token is there
  for (int i = 0; i < 4096; i++){
    if(dir_entries[i].dir_type !=0){
      if(strcmp(dir_entries[i].name, token) == 0){ //if we find a match
        if ((strcmp(token,last) ==0) && (strlen(path) == strlen(last))){ //if last component     
          strcpy(de->name,dir_entries[i].name);
          de->first_cluster = dir_entries[i].first_cluster;
          de->file_size = dir_entries[i].file_size;
          de->dir_type = dir_entries[i].dir_type;
          return 0;
        }else{
          if (dir_entries[i].dir_type == 0) isFile = 1; //if match is file
          else{ //if match is dir
            char path2[strlen(path)];
            for (int j = 0; j < strlen(path); j++){
              path2[j] = path[j+index];
            }
            return dir_exists(path2, dir_entries[i].first_cluster, de, last);
          }
        }
      }
    }
  }
  if(isFile == 1) return -3;
  de = NULL;
  return -1;
}




/*
  key: finish the find_dir method, getattr should check if target dir exists, if so 
  fill the stat struct *stbuf with the information in the dir_entry and return
  if desired dir doesn't exist, return -ENOENT?
  mkdir is gonna suck 
*/
//return file attributes, for path name, should fill in the elements of the stat struc 
//if a field is meaningless then it should be set to 0
static int fat_getattr(const char *path, struct stat *stbuf)
{

  int res = 0;

  memset(stbuf, 0, sizeof(struct stat));

  // see if name is too long
  char *mayberoot = strdup(path);

  if((strlen(basename(mayberoot))>32) || (strlen(path) > PATH_MAX)){
    return -ENAMETOOLONG;
  }

  // if root  
  if (strcmp(path, "/") == 0) {
    // get directory size, and the rest is the usual
    dir_entry dir_entries[4096];//[((4096/sizeof(dir_entries)) + 1)];
    memset(dir_entries, 0, sizeof(dir_entries));
    pread(fd_disk, &dir_entries, 4096, (4096*4));

    stbuf -> st_mode = S_IFDIR | dir_entries[0].mode;
    stbuf -> st_nlink = dir_entries[0].file_size;
    stbuf -> st_size = 4096;
    stbuf -> st_blocks = 1;
    return res;
  } else {

    // prepare for dir_exists call 
    char path2[PATH_MAX];
    strcpy(path2,path);
    if(path2[0] == '/'){
      // remove root
      memmove(path2, path2+1, sizeof(path2)-1); //same fix as in getattr 
    }
    // get name of dir we want    
    char *dup = strdup(path2);
    char *last;
    last = basename(dup);

    int cluster_num = 4;
    dir_entry de;

    //if path doesn't exist or name is too long, return error   
    int call_rslt = dir_exists(path2,cluster_num,&de, last);
    if (call_rslt == -1) return -ENOENT;
    if (call_rslt == -2) return -ENAMETOOLONG;
    if (call_rslt == -3) return -ENOTDIR;
    else if (de.dir_type == 1) { //if path does exist, return correct attributes  
      //stbuf -> st_mode = S_IFDIR | 0755;
      stbuf -> st_mode = S_IFDIR | de.mode;

      stbuf -> st_nlink = de.file_size;
      stbuf -> st_size = 4096;
      stbuf -> st_blocks = 1;
    }else{
      // check permissions    
      //if(de.read_only == 1) stbuf -> st_mode = S_IFREG | 0444;
      //else stbuf->st_mode = S_IFREG | 0666;
      
      stbuf->st_mode = S_IFREG | de.mode;

      stbuf -> st_nlink = 1;
      stbuf -> st_size = de.file_size; // by multiple of blocks
      int b = (de.file_size/4096);
      if((de.file_size%4096) != 0) b++;
      stbuf -> st_blocks = b;
    }
  }
  return res;
}





static int fat_access(const char *path, int mask)
{

  // see if name is too long
  if((strlen(basename(strdup(path)))>32) || (strlen(path) > PATH_MAX)){
    return -ENAMETOOLONG;
  }
  

  // i am groot
  if (strcmp(path, "/") == 0) {
    return 0;
  } else {

    // prepare for dir_exists call
    char path2[PATH_MAX];
    strcpy(path2,path);
    if(path2[0] == '/'){
      // path2++;
      memmove(path2, path2+1, sizeof(path2)-1); //same fix as in getattr
    }

    // get name of dir we want
    char *dup = strdup(path2);
    char *last;
    last = basename(dup);

    int cluster_num = 4;
    dir_entry de;

    // if path doesn't exist, return error
    int call_rslt = dir_exists(path2,cluster_num,&de, last);
    if (call_rslt == -1) return -ENOENT;
    if (call_rslt == -2) return -ENAMETOOLONG;
    if (call_rslt == -3) return -ENOTDIR;
    else if (de.dir_type == 1){ // if path does exist, check for permissions
      // but all directories are 0755 so...
      return 0;
    }else{
      if( (mask & W_OK) && (!(de.mode & W_OK)) ){
	return -EACCES;
      }
      return 0;
    }
  }

}






static int fat_readdir(const char *path, dir_entry *ret, off_t offset)
{
  // see if name is too long
  if((strlen(basename(strdup(path)))>32) || (strlen(path) > PATH_MAX)){
    return -ENAMETOOLONG;
  }

  // get respective cluster number (4 for groot)
  int cluster_num = 4;

  if(strcmp(path, "/") != 0){
    // prepare for dir_exists call
    char path2[PATH_MAX];
    strcpy(path2,path);
    if(path2[0] == '/'){
      // path2++;
      memmove(path2, path2+1, sizeof(path2)-1); //same fix as in getattr
    }

    // get name of dir we want
    char *dup = strdup(path2);
    char *last;
    last = basename(dup);

    dir_entry de;

    int call_rslt = dir_exists(path2,cluster_num,&de, last);
    if (call_rslt == -1) return -ENOENT;
    if (call_rslt == -2) return -ENAMETOOLONG;
    if (call_rslt == -3) return -ENOTDIR;
    cluster_num = de.first_cluster;
  }


  dir_entry dir_entries[4096];
  memset(dir_entries, 0, sizeof(dir_entries));
  pread(fd_disk, &dir_entries, 4096, (4096*cluster_num));


  //search through to add all dir_entries in directory
  int i;
  for (i = 0; i < 4096; i++){
    if(dir_entries[i].dir_type !=0){
      strcpy(ret[i].name, dir_entries[i].name);
      ret[i].first_cluster = dir_entries[i].first_cluster;
      ret[i].file_size = dir_entries[i].file_size;
      ret[i].dir_type = dir_entries[i].dir_type;
      ret[i].mode = dir_entries[i].mode;
    }
  }

  return 0;
}






static int fat_mkdir(const char* path, mode_t mode)
{

  // separate path and name of last dir
  char *parent_path = dirname(strdup(path));
  char *dir_name = basename(strdup(path));


  // can't make root
  if(strcmp(path,"/") == 0) return -ENOENT;
  
  // see if name is too long
  if((strlen(basename(strdup(path)))>32) || (strlen(path) > PATH_MAX)){
    return -ENAMETOOLONG;
  }
  
  dir_entry parent_de;
  dir_entry grandparent_de;



  char path2[PATH_MAX];
  strcpy(path2,path);
  if(path2[0] == '/'){
    // path2++;
    memmove(path2, path2+1, sizeof(path2)-1); //same fix as in getattr
  }
  // check if directory already exists (using parent_de, but not looking for parent directory entry, just for convenience)
  int call_rslt = dir_exists(path2, 4, &parent_de, dir_name);
  if (call_rslt == -2) return -ENAMETOOLONG;
  if (call_rslt == 0) return -EEXIST;
  if (call_rslt == -3) return -ENOTDIR;
  //  memset(&parent_de,0,sizeof(parent_de));


  dir_entry dir_entries[4096];//[((4096/sizeof(dir_entries)) + 1)];
  memset(dir_entries, 0, sizeof(dir_entries));

  // check if path leading to directory doesn't exist
  if(strcmp(parent_path,"/") == 0) { // i am groot
    //get appropriate directory entry for root
    pread(fd_disk, &dir_entries, 4096, (4096*4));
    parent_de.first_cluster = 4;
    parent_de.file_size = dir_entries[0].file_size;
    strcpy(parent_de.name,".");
    parent_de.dir_type = 1;
  } else { //if not root,
    // prepare for dir_exists call

    strcpy(path2,parent_path);
    if(path2[0] == '/'){
      // path2++;
      memmove(path2, path2+1, sizeof(path2)-1); //same fix as in getattr
    }

    // get name of dir we want
    char *dup = strdup(path2);
    char *last;
    last = basename(dup);

    int call_rslt = dir_exists(path2, 4, &parent_de, last);
    if (call_rslt == -1) return -ENOENT; //doesn't exist

    // if parent isn't groot, we know it has a grandparent
    // all we need is the cluster number, so get it from .. of parent
    pread(fd_disk,&dir_entries, 4096, (4096*parent_de.first_cluster));
    grandparent_de.first_cluster = dir_entries[1].first_cluster;
  }
  // check if there is space for more directory entries
  int max = (4096/ sizeof(dir_entry));
  if (parent_de.file_size >= max) return -ENOSPC;






  for(int i= 0; i <2556; i++){
    // if we find an empty cluster
    if(fat[i] == 4000){
      // set cluster to endoffile and write out
      fat[i] = 3000;
      pwrite(fd_disk,&fat, (4096*3), 4096);


      // FOR NEW DIR ENTRY IN NEW CLUSTER
      // creating new dir entry
      memset(dir_entries,0,sizeof(dir_entries));

      dir_entry de;
      de.first_cluster = i+4;
      de.file_size = 2;
      de.dir_type = 1;
      de.mode = (mode | S_IFDIR);
      memset(de.name,0,sizeof(de.name));
      strcpy(de.name,".");
      dir_entries[0] = de;

      dir_entries[1].first_cluster = parent_de.first_cluster;
      dir_entries[1].file_size = ((parent_de.file_size)+1);
      dir_entries[1].dir_type = 1;
      strcpy(dir_entries[1].name,"..");

      //write out new directory cluster
      pwrite(fd_disk,&dir_entries, 4096, (4096*(i+4)));



      // FOR CHANGING PARENT CLUSTER
      // read in parent cluster
      pread(fd_disk,&dir_entries, 4096, (4096*parent_de.first_cluster));

      // change parent cluster
      strcpy(de.name,basename(strdup(path)));
      for (int j = 0; j < max; j++){
	if(dir_entries[j].dir_type == 0){
	  dir_entries[j] = de;
	  break;
	}
      }
      // update size in .
      dir_entries[0].file_size++;

      // check if parent cluster is root
      if(parent_de.first_cluster == 4){
	// then also have to update ..
	dir_entries[1].file_size++;
      }
      // write out parent cluster
      pwrite(fd_disk,&dir_entries, 4096, (4096*parent_de.first_cluster));



      // POSSIBLY CHANGING GRANDPARENT CLUSTER
      // if there is a grandparent
      if(strcmp(parent_path,"/") != 0){
	// read in grandparent cluster
	pread(fd_disk,&dir_entries, 4096, (4096*grandparent_de.first_cluster));
	// change parent dir entry in gp cluster
	for (int j = 0; j < 4096; j++){
	  //if valid dir entry
	  if(dir_entries[j].dir_type != 0){
	    // check if is the parent dir entry
	    if(strcmp(dir_entries[j].name,parent_de.name) == 0){
	      dir_entries[j].file_size++;
	    }
	  }
	}
	pwrite(fd_disk,&dir_entries,4096,(4096*grandparent_de.first_cluster));
      }


      return 0;
    }
  }

  return -ENOSPC;
}







static int fat_rmdir(const char* path)
{

  // separate path and name of last dir
  char *parent_path = dirname(strdup(path));
  char *dir_name = basename(strdup(path));


  // can't make root
  if(strcmp(path,"/") == 0) return -ENOENT;

  // see if name is too long
  if((strlen(basename(strdup(path)))>32) || (strlen(path) > PATH_MAX)){
    return -ENAMETOOLONG;
  }

  dir_entry de;
  dir_entry parent_de;
  dir_entry grandparent_de;



  char path2[PATH_MAX];
  strcpy(path2,path);
  if(path2[0] == '/'){
    // path2++;
    memmove(path2, path2+1, sizeof(path2)-1); //same fix as in getattr
  }
  // check if directory already exists (using parent_de, but not looking for parent directory entry, just for convenience)
  int call_rslt = dir_exists(path2, 4, &de, dir_name);
  if (call_rslt == -2) return -ENAMETOOLONG;
  if (call_rslt == -1) return -ENOENT;
  if (call_rslt == -3) return -ENOTDIR;
  if (de.dir_type == 2) return -ENOTDIR;



  dir_entry dir_entries[4096];//[((4096/sizeof(dir_entries)) + 1)];
  memset(dir_entries, 0, sizeof(dir_entries));

  // check if path leading to directory doesn't exist
  if(strcmp(parent_path,"/") == 0) { // i am groot
    //get appropriate directory entry for root
    pread(fd_disk, &dir_entries, 4096, (4096*4));
    parent_de.first_cluster = 4;
    parent_de.file_size = dir_entries[0].file_size;
    strcpy(parent_de.name,".");
    parent_de.dir_type = 1;
  } else { //if not root,
    // prepare for dir_exists call

    strcpy(path2,parent_path);
    if(path2[0] == '/'){
      // path2++;
      memmove(path2, path2+1, sizeof(path2)-1); //same fix as in getattr
    }

    // get name of dir we want
    char *dup = strdup(path2);
    char *last;
    last = basename(dup);

    dir_exists(path2, 4, &parent_de, last);

    // if parent isn't groot, we know it has a grandparent
    // all we need is the cluster number, so get it from .. of parent
    pread(fd_disk,&dir_entries, 4096, (4096*parent_de.first_cluster));
    grandparent_de.first_cluster = dir_entries[1].first_cluster;
  }

  // check if directory is empty
  pread(fd_disk, &dir_entries, 4096, (4096*de.first_cluster));
  for (int i = 2; i < 4096; i++){
    if (dir_entries[i].dir_type != 0){
      return -ENOTEMPTY;
    }
  }
  // 0 out the dir entry in parent
  pread(fd_disk, &dir_entries, 4096, (4096*parent_de.first_cluster));
  dir_entries[0].file_size--;

  for (int i = 2; i < 4096; i++){
    if (strcmp(dir_entries[i].name, de.name) == 0){
      memset(&dir_entries[i], 0, sizeof(dir_entry));
      break;
    }
  }
  if (strcmp(parent_de.name, "/") == 0){
    dir_entries[1].file_size--;
  }
  pwrite(fd_disk, &dir_entries, 4096, (4096*parent_de.first_cluster));

  // 0 out the dir cluster
  memset(&dir_entries, 0, 4096);
  pwrite(fd_disk, &dir_entries, 4096, (4096*de.first_cluster));


  // set fat entry as free
  fat[de.first_cluster - 4] = 4000;
  pwrite(fd_disk, &fat, 3*4096, 4096);


  // decrease file size of parent in grandparent
  if (parent_de.first_cluster != 4){
    pread(fd_disk, &dir_entries, 4096, (4096*grandparent_de.first_cluster));
    for (int i = 2; i < 4096; i++){
      if (strcmp(dir_entries[i].name, parent_de.name) == 0){
	dir_entries[i].file_size--;
	break;
      }
    }
    pwrite(fd_disk, &dir_entries, 4096, (4096*grandparent_de.first_cluster));
  }
  return 0;
}







static int fat_mknod(const char* path, mode_t mode, dev_t rdev)
{
  //check mode 
  if(S_ISREG(mode)){

    // separate path and name of last dir
    char *dup1 = strdup(path);
    char *dup2 = strdup(path);
    char *parent_path = dirname(dup1);
    char *file_name = basename(dup2);

    // can't make root 
    if(strcmp(path,"/") == 0) return -ENOENT;
    // see if name is too long 
    if((strlen(basename(strdup(path)))>32) || (strlen(path) > PATH_MAX)){
      return -ENAMETOOLONG;
    }

    dir_entry parent_de;
    dir_entry grandparent_de;



    char path2[PATH_MAX];
    strcpy(path2,path);
    if(path2[0] == '/'){
      // path2++;
      memmove(path2, path2+1, sizeof(path2)-1); //same fix as in getattr
    }
    // check if directory already exists (using parent_de, but not looking for parent directory entry, just for convenience)
    int call_rslt = dir_exists(path2, 4, &parent_de, file_name);
    if (call_rslt == -2) return -ENAMETOOLONG;
    if (call_rslt == 0) return -EEXIST;
    if (call_rslt == -3) return -ENOTDIR;
    //  memset(&parent_de,0,sizeof(parent_de));

    dir_entry dir_entries[4096];//[((4096/sizeof(dir_entries)) + 1)];
    memset(dir_entries, 0, sizeof(dir_entries));

    // check if path leading to directory doesn't exist
    if(strcmp(parent_path,"/") == 0) { // i am groot
      //get appropriate directory entry for root
      pread(fd_disk, &dir_entries, 4096, (4096*4));
      parent_de.first_cluster = 4;
      parent_de.file_size = dir_entries[0].file_size;
      strcpy(parent_de.name,".");
      parent_de.dir_type = 1;
    } else { //if not root,
      // prepare for dir_exists call 

      strcpy(path2,parent_path);
      if(path2[0] == '/'){
        // path2++;
        memmove(path2, path2+1, sizeof(path2)-1); //same fix as in getattr
      }

      // get name of dir we want
      char *dup = strdup(path2);
      char *last;
      last = basename(dup);

      int call_rslt = dir_exists(path2, 4, &parent_de, last);
      if (call_rslt == -1) return -ENOENT; //doesn't exist

      // if parent isn't groot, we know it has a grandparent
      // all we need is the cluster number, so get it from .. of parent
      pread(fd_disk,&dir_entries, 4096, (4096*parent_de.first_cluster));
      grandparent_de.first_cluster = dir_entries[1].first_cluster;
    }
    // check if there is space for more directory entries 
    int max = (4096/ sizeof(dir_entry));
    if (parent_de.file_size >= max) return -ENOSPC;


    for(int i= 0; i <2556; i++){
      // if we find an empty cluster 
      if(fat[i] == 4000){
        // set cluster to endoffile and write out
        fat[i] = 3000;
        pwrite(fd_disk,&fat, (4096*3), 4096);


        // FOR NEW DIR ENTRY IN NEW CLUSTER
        // creating new dir entry 
        dir_entry de;
        de.first_cluster = i+4;
        de.file_size = 0;
        de.dir_type = 2;


        //check mode to get permissions  
        
	//if (mode == (S_IFREG | 0444)) de.mode = S_IFREG | 0444;
        //else de.mode = ;
        de.mode = S_IFREG | mode;
	memset(de.name,0,sizeof(de.name));
        strcpy(de.name,file_name);


        // FOR CHANGING PARENT CLUSTER 
        // read in parent cluster
        pread(fd_disk,&dir_entries, 4096, (4096*parent_de.first_cluster));

        // change parent cluster
        for (int j = 0; j < max; j++){
          if(dir_entries[j].dir_type == 0){
            dir_entries[j] = de;
            break;
          }
        }
        // update size in .
        dir_entries[0].file_size++;

        // check if parent cluster is root
        if(parent_de.first_cluster == 4){
          // then also have to update ..
          dir_entries[1].file_size++;
        }
        // write out parent cluster
        pwrite(fd_disk,&dir_entries, 4096, (4096*parent_de.first_cluster));

        // POSSIBLY CHANGING GRANDPARENT CLUSTER
        // if there is a grandparent 
        if(strcmp(parent_path,"/") != 0){
          // read in grandparent cluster
          pread(fd_disk,&dir_entries, 4096, (4096*grandparent_de.first_cluster));
          // change parent dir entry in gp cluster     
          for (int j = 0; j < 4096; j++){
            //if valid dir entry
            if(dir_entries[j].dir_type != 0){
              // check if is the parent dir entry
              if(strcmp(dir_entries[j].name,parent_de.name) == 0){
                dir_entries[j].file_size++;
              }
            }
          }
          pwrite(fd_disk,&dir_entries,4096,(4096*grandparent_de.first_cluster));
        }
        return 0;
      }
    }
    return -ENOSPC;
  }
  return -EACCES;
}






///////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////// user command interpretation ///////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////







static void throw_error(int err, char *instruct, char *path){
  ///////////////////// ERRORS!!! ///////////////////////
  if(err == 0) return;
  
  else{
    // base
    if(path) printf("%s: %s: ", instruct, path);
    else printf("%s: ", instruct);

    if(err == -ENOTPERM) printf("Operation not permitted.\n");
    else if(err == -ENOENT) printf("File doesn't exist.\n");
    else if(err == -EACCES) printf("Permission denied.\n");
    else if(err == -EEXIST) printf("File already exists.\n");
    else if(err == -ENOTDIR) printf("Not a directory.\n");
    else if(err == -EISDIR) printf("Is an existing directory.\n");
    else if(err == -ENOSPC) printf("No more space.\n");
    else if(err == -EMLINK) printf("Too many links.\n");
    else if(err == -ENAMETOOLONG) printf("File or path name too long.\n");
    else if(err == -ENOTEMPTY) printf("Directory not empty.\n");
    else if(err == -ELOOP) printf("Too many links.\n");
  }
  return;
}








int option_helper(char *instruct, char *command, char *paths, char *options, int *p_found){

  if(command == NULL) return 0;
  
  char *op;
  op = malloc(COM_LENGTH);
  memset(op, 0, COM_LENGTH);
  
  memset(paths, 0, COM_LENGTH);

  int path_found = 0; //after this turns to 1, no options can be taken in

  int op_index = 0;

  if(strtok(strdup(command), " ") == NULL){
    strcpy(op,command);
  }
  else {
    strcpy(op,strtok(strdup(command), " "));
  }
  while(op){

    if(strcmp(instruct, "cd") == 0){
      if(strstr(command, " -") != NULL){
	free(op);
	return -1; // cd shouldn't have any options
      }
      else{ //if a path, we only need the first path. We ignore all other paths user may have written. Unix rules, not me.
	strcpy(paths,op);
	*p_found = 1;
	free(op);
	return 0;
      }
    }

    else if(strcmp(instruct, "ls") == 0){ //supports -l, -a
      if((op[0] != '-') || (path_found != 0)){ // found a path, or found a path previously
	if(path_found == 0) strcpy(paths, op); // if first time, add path
	else{ // if not first path, add a space to divide, then add new path
	  strcat(paths, " ");
	  strcat(paths, op);
	}
	path_found++;
      }
      else{ //found an option
	for(int i = 1; i < strlen(op); i++){ // from index 1 because we gotta ignore '-'
	  if((op[i] == 'l') || (op[i] == 'a')){ //if it has any of these (don't care about repeats)
	    if(op_index == 0) strcpy(options, (op + 1)); //if first option, add option
	    else{ //f not first option, add a space to divide, then add new option
	      strcat(options, " ");
	      strcat(options, (op + 1));
	    }
	    op_index++;
	  }
	  else{
	    free(op);
	    return -1; //if not -a or -l or -la or -al, return -1
	  }
	}
      }

    }

    else if(strcmp(instruct, "more") == 0){
      
    }

    else if(strcmp(instruct, "less") == 0){
      
    }

    else if(strcmp(instruct, "mkdir") == 0){ // supports -m, -p, -v
      // not an option/path has been found
      if((op[0] != '-') || (path_found != 0)){
	if(path_found == 0) strcpy(paths, op);
	else{
	  strcat(paths, " ");
	  strcat(paths, op);
	}
	path_found++;
      }
      else{ // its possibly a valid option
	for(int i = 1; i < strlen(op); i++){ //scrutinize from after '-'
	  if((op[i] == 'p') || (op[i] == 'v')){

	    if(op_index == 0) strcpy(options, (op + 1)); //if first option, add option
	    else{ //f not first option, add a space to divide, then add new option
	      strcat(options, " ");
	      strcat(options, (op + 1));
	    }
	    op_index++;
	  }

	  else if(op[i] == 'm'){
	    if(i != (strlen(op) -1)){ //if there's a option following this one, error
	      free(op);
	      return -1; 
	    }
	    else if((op = strtok(NULL, " ")) && (op[0] != '-')){ // if it has something following it, and is not an option
	      
	      if(op_index == 0){ //if first option, add option
		strcpy(options, "m ");
		strcat(options, op); 
	      }
	      else{ //f not first option, add a space to divide, then add new option
		strcat(options, " m ");
		strcat(options, op);
	      }
	      op_index++;

	    }
	    else{ //otherwise, if it has nothing following it, or has a option following it, error
	      free(op);
	      return -1; 
	    }
	  }
	  
	}
      }

    }

    else if(strcmp(instruct, "rmdir") == 0){ // supports -p
      if((op[0] != '-') || (path_found != 0)){
	if(path_found == 0) strcpy(paths, op);
	else{
	  strcat(paths, " ");
	  strcat(paths, op);
	}
	path_found++;
      }
      else if(strcmp(op,"-p") == 0) // because p is the only option
	op_index = 1; 
      }
      else{
	free(op);
	return -1;
      }
    }
    else { //"echo"
    
    }

    op = strtok(NULL, " ");
  }
  
  if((path_found == 0) && (strcmp(instruct, "mkdir") == 0) && (strcmp(instruct, "rmdir") == 0)) return -1;
  
  *p_found = path_found;
  free(op);
  return op_index;
}






char* nodots_helper(char *path){ 

  char ret[COM_LENGTH];
  char dup[COM_LENGTH];
  char dup2[COM_LENGTH];

  memset(ret,0,COM_LENGTH);
  memset(dup,0,COM_LENGTH);
  memset(dup2,0,COM_LENGTH);

  //cases
  // case1: just "/."
  if(strcmp(path,"/.") == 0){
    memset(path,0,strlen(path));
    path[0] = '/';
    return path;
  }
  // case2: just "/.."
  else if(strcmp(path,"/..") == 0){
    memset(path,0,strlen(path));
    path[0] = '/';
    return path;
  }
  // case 3: starts with "/./...", or has "..././..."
  else if(strstr(path,"/./") != NULL){
    // see if it starts "/./"
    if(strcmp(strstr(path,"/./"),path) == 0){
      // just remove /.
      path = path+2;
      strcpy(ret,path);
    }    
    else{ //if "..././..."
      // get index of /./
      int index = strstr(path, "/./") - path;
      // split into two halves, without /.
      strcpy(dup,(strstr(path, "/./") + 2));
      strncpy(ret,path,index);
      // merge
      strcat(ret,dup);
    }
    return nodots_helper(ret);
  }
  // case4: //starts with "/../...", or has ".../../..."
  else if(strstr(path,"/../") != NULL){
    // see if it starts with "/../"
    if(&(strstr(path,"/../")[0]) == & path[0]){
      // just remove /..
      path = path+3;
      strcpy(ret,path);
    }     
    //if ".../../..." (because strstr always looks for the first instance, we never are looking at the second of /../../, for example
    else{ 
      // get index of /../
      int index = strstr(path, "/../") - path;
      // copy first half
      strncpy(dup2,path,index);
      // remove last directory of first half
      strcpy(ret,dirname(dup2));
      //incase we've come down to root. Then dirname(dup2) returns / -> "//nextfile/..."
      if(strcmp(ret,"/") == 0) strcpy(dup,(strstr(path, "/../") + 4));
      // copy second half without /..
      else strcpy(dup,(strstr(path, "/../") + 3));
      // merge
      strcat(ret,dup);
    }
    return nodots_helper(ret);
  }
  // case 5: seeing if path ends with "/." or "/.."
  else if(strstr(path,"/.") != NULL){
    //if path ends with /. (otherwise, it would be /./, or /.hi and etc.
    if(strcmp(strstr(path,"/."),"/.") == 0){       
      // get rid of /.
      strcpy(ret,dirname(path));
      return nodots_helper(ret);
    }
    //if path ends with /.. (otherwise, it would be /../, or /..hi and etc.
    else if(strcmp(strstr(path,"/.."),"/..") == 0){ 
      // get rid of /.. and previous directory
      strcpy(dup,dirname(path));
      strcpy(ret,dirname(dup));
      return nodots_helper(ret);
    }
  }
  // case 6: no dots
  else {
    // absolute bliss
    return path;
  }
  // shouldn't reach here, but...
  return path;
}




// supports -al
static int i_ls(char *path, char *options, int opt_num){

  // read in subfiles of working directory
  
  int err = 0;
  
  dir_entry dir_entries[4096];
  memset(dir_entries, 0, sizeof(dir_entry)*4096);

  
  // in working directory
  if(path == NULL || (strcmp(path,"/") == 0)){
    // see if working directory is root
    if(strcmp(workdir,rootdir) == 0){
      err = fat_readdir(rootdir, dir_entries, 0);
    }
    else {
      char *dup = strdup(workdir);
      
      err = fat_readdir(dup, dir_entries, 0);
    }
  }
  else {    // in another directory
    
    // concat the workdir with further path
    // first check if the path + workdir exceeds path name length
    if((strlen(path) + strlen(workdir)) > PATH_MAX) return -ENAMETOOLONG;
    
    char *dup1 = strdup(workdir);
    strcat(dup1,path);
    
    err = fat_readdir(dup1, dir_entries, 0);
      
  }
  
  if(err != 0) return err;
  
  // print out subfiles of de.
    for(int i = 0; i <4096; i++){
      
      if((dir_entries[i].dir_type != 0)){ // if no options
	if(opt_num == 0){
	  if(dir_entries[i].name[0] != '.') printf("%s\t\t", dir_entries[i].name);
	}
	else if((dir_entries[i].name[0] == '.') && (strchr(options, 'a') == NULL)) { // unless option '-a', hidden files are hidden!
	  // if it starts with . but doesn't have '-a' option
	}
	else if(strchr(options, 'l') != NULL){
	  int mode = dir_entries[i].mode;

	  if((mode & S_IFDIR) != 0) printf("d");
	  else if((mode & S_IFREG) != 0) printf("-");

	  if((mode & S_IRUSR) != 0) printf("r");
	  else printf("-");

	  if((mode & S_IWUSR) != 0) printf("w");
	  else printf("-");

	  if((mode & S_IXUSR) != 0) printf("x");
	  else printf("-");

	  if((mode & S_IRGRP) != 0) printf("r");
	  else printf("-");

	  if((mode & S_IWGRP) != 0) printf("w");
	  else printf("-");

	  if((mode & S_IXGRP) != 0) printf("x");
	  else printf("-");

	  if((mode & S_IROTH) != 0) printf("r");
	  else printf("-");

	  if((mode & S_IWOTH) != 0) printf("w");
	  else printf("-");

	  if((mode & S_IXOTH) != 0) printf("x ");
	  else printf("- ");


	  // merry christmas.
	  printf("%d\t%s\t%s\t%d %s %d %d:%d %s\n", 1, "user", "group", dir_entries[i].file_size, "Dec", 25, 12, 25, dir_entries[i].name);
	}
	else printf("%s\t\t", dir_entries[i].name);
      }
    }
    printf("\n");


  // if there are descriptions, switch by case (if statements in c)
  return 0;
}






static int i_cd(char *path, char *options, int opt_num){


  // read in subfiles of working directory
  
  // in working directory
  if((path == NULL) || (strcmp(path,"/") == 0)){
    
    //change working directory to root
    strcpy(workdir,rootdir);
    workdir_clusternum = 4;
  }
  else if(strcmp(path,".") == 0){
    // how wonderful. no work.
    return 0;
  }
  else if(strcmp(path,"..") == 0){
    // if in root, no work.
    if(strcmp(workdir,rootdir) == 0){
      return 0;
    }
    // change working directory to previous directory
    strcpy(workdir,dirname(strdup(workdir)));
    
    // get working directory cluster num
    dir_entry de;
    dir_exists(workdir, 4, &de, basename(strdup(workdir)));
    workdir_clusternum = de.first_cluster;

    return 0;
  }
  else {    // in another directory


    char dup[COM_LENGTH];
    strcpy(dup,path);

    
    // check if path is from root
    if(path[0] == '/'){}//dont do anything
    // or if working directory is root
    else if (strcmp(workdir,rootdir) == 0){
      memset(dup, 0, strlen(dup));
      strcpy(dup, rootdir); //set beginning as /
      strcat(dup, path);
    }      
    else { // if path is from working directory, concat with workdir path
      // see if path doesn't exceed size
      if((strlen(workdir) + strlen(path)) > PATH_MAX){
	return -ENAMETOOLONG;
      }
      memset(dup, 0, strlen(dup));
      strcpy(dup, workdir);
      strcat(dup,"/");
      strcat(dup,path);
    }


    int err = 0;
    err = fat_access(dup,R_OK);    //path still works without taking care of . and ..
    if(err != 0){
      return err;
    }

    // take care of . and ..
    char dup2[COM_LENGTH];
    strcpy(dup2,dup);
    memset(dup,0,strlen(dup));
    strcpy(dup,nodots_helper(dup2));



    
    // change working directory to this one
    strcpy(workdir,dup);

    // get working directory cluster num
    dir_entry de;
    dir_exists(workdir,4,&de,basename(strdup(workdir)));
    workdir_clusternum = de.first_cluster;
  }

  // if there are descriptions, switch by case (if statements in c)
  return 0;
}



//supports -mpv
static int i_mkdir(char *path, char *options, int opt_num){

  
  int err = 0;
  

  // no path?
  if(path == NULL){
    return -ENOENT;
  }
  
  else {    // making new directory

    // check options
    int m = -1;
    int p = 0;
    int v = 0;  
    
    char option[COM_LENGTH];


    if(strchr(options, 'p') != NULL) p = 1;
    else if(strchr(options, 'v') != NULL) v = 1;
    else if(strchr(options, 'm') != NULL){

      m = 0;

      int i = (strstr(options, "m ") - options) + 3;
      //make sure permission bits are in correct format
      for(int j = 0; j < 3; j++){
	
	// if permission bits are 0 through 7, set the corresponding m bit
	if(((options[i+j] - '0') == 0 ) || ((options[i+j] - '0') <= 7))   m = m + ((options[i+j] - '0') * pow(8,(2-j)));
	
	else return -ECOMMAND;
      }
    }


    // if m wasn't set to a certain permission bit, all dirs are 0755
    if(m == -1) m = 0755;


    char *dup;

    // check if path is from root
    if(path[0] == '/') dup = strdup(path);
    // or if working directory is root
    else if (strcmp(workdir,rootdir) == 0){
      dup = strdup(rootdir);
      strcat(dup,path);
    }
    else { // if path is from working directory, concat with workdir path
      // see if path doesn't exceed size
      if((strlen(workdir) + strlen(path)) > PATH_MAX){
	return -ENAMETOOLONG;
      }

      dup = strdup(workdir);
      strcat(dup,"/");
      strcat(dup,path);

      
    }

    
    //check permission in parent directory
    if(fat_access(dirname(strdup(dup)), W_OK) == -EACCES) return -EACCES; //if in root, dirname will just return root (assuming root == /)



    err = fat_mkdir(dup, m);


    // if a directory in path doesn't exist
    if (err == -ENOENT){

      // if option -p, then make all the directories as needed. Unless some other error shows up
      if(p != 0){

	err = i_mkdir(dirname(strdup(dup)),options,opt_num);

	// if previous directories were created successfully, let there be directory
	if(err == 0) err = fat_mkdir(dup,m); 
      }

      // otherwise, user wrote a stupid command. blame the player not the game.
      else return -ENOENT;
    }

    if((v == 1) && (err == 0)) printf("mkdir: created directory '%s'\n", path);
  }
  


  // if there are descriptions, switch by case (if statements in c)
  return err;


}







static int i_rmdir(char *path){

  int err = 0;

  // no path?
  if(path == NULL){
    return -ENOENT;
  }
  
  else {    // making new directory
      //check permission in parent directory
    
    // check if path is from root
    if(path[0] == '/') err = fat_rmdir(path);
    // or if working directory is root
    else if (strcmp(workdir,rootdir) == 0) err = fat_rmdir(strcat(strdup(rootdir),path));
    else { // if path is from working directory, concat with workdir path
      // see if path doesn't exceed size
      if((strlen(workdir) + strlen(path)) > PATH_MAX){
	return -ENAMETOOLONG;
      }

      char *dup = strdup(workdir);
      strcat(dup,"/");
      strcat(dup,path);
      err = fat_rmdir(dup);
      
    }

  }
  

  return err;

}







////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////  MAIN MAIN MAIN MAIN ///////////////////////////////////////////////////// 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



int main(){

  // initialize
  fat_init();

  // tell user how to use
  printf("\nFAT Filesystem (c)2020  Jae Surh: \nVirtual simulation of a filesystem. Memory stored on a file called 'fat_disk'.\nSupports Unix commands. Place the path after the command and descriptions, if any.\nType 'quit' then enter, to quit.\n\n");



  //prepare for command
  char command[COM_LENGTH];

  int err = 0;

  printf("%s user: ", workdir);

  // continuously get commands, until quit.
  fgets(command, COM_LENGTH, stdin);
  while (strcmp(command, "quit\n") != 0) {
    
    // get rid of \n at the end of the string
    command[(strlen(command)-1)] = 0;


    // if command has no path or description
    if(strchr(command, ' ') == NULL){
      
      if(strcmp(command,"ls") == 0){
	err = i_ls(NULL, NULL, 0);
	throw_error(err,"ls",NULL);
      }
      else if(strcmp(command,"cd") == 0){
	err = i_cd(NULL, NULL, 0);
	throw_error(err,"cd",NULL);
      }
      else if(strcmp(command,"mkdir") == 0){ //should there be an error inherent
	printf("mkdir: usage: mkdir [-pv] [-m mode] directory ...\n");
      }
      else if(strcmp(command,"rmdir") == 0){
	printf("rmdir: usage: rmdir [-p] directory ...\n");
      }
      else if(strlen(command) == 0){
	// do you wanna build a snow man-
	// okay bye
      }
      else{
	printf("Error: Command not recognized\n");
      }
    }
    else{

      //split into command and rest
      char mand[COM_LENGTH];
      memset(mand,0,COM_LENGTH);
      strcpy(mand,strchr(command, ' ')+1);

      int index = strchr(command, ' ') - command;
      char com[COM_LENGTH];
      memset(com,0,COM_LENGTH);
      strncpy(com,command,index);


      // prepare to read in options and paths
      char *paths = malloc(COM_LENGTH);
      char *options = malloc(COM_LENGTH);
      
      int path_num = 0;
      // stop, drop, and read
      int opt_num = 0;
      opt_num = option_helper(com,mand,paths,options,&path_num);
      
      char *path = malloc(COM_LENGTH);

      if(strcmp(com,"ls") == 0){
	// if command is in incorrect form
	if(opt_num == -1) printf("ls: usage: ls [-al] directory ...\n");
	
	// if there is no path
	if(path_num == 0){
	  err = i_ls(NULL, options, opt_num);
	  throw_error(err, "ls", NULL);
	}

	// for all the paths there are
	path = strtok(paths," ");
	while(path){
	  err = i_ls(path, options, opt_num);
	  throw_error(err, "ls", path);
	  path = strtok(NULL, " ");
	}
      }


      else if(strcmp(com,"cd") == 0){
	// if command is in incorrect form
	if(opt_num == -1) printf("cd: usage: cd directory ...\n");

	// if there is no path
	if(path_num == 0){
	  err = i_cd(NULL, options, opt_num);
	  throw_error(err, "ls", NULL);
	}
	
	// just for the first path
	path = strtok(paths, " ");
	err = i_cd(path, options, opt_num);
	throw_error(err, "cd", path);
      }


      else if(strcmp(com,"more") == 0){
	
      }


      else if(strcmp(com,"less") == 0){
	
      }


      else if(strcmp(com,"mkdir") == 0){
	// if command is in incorrect form
	if((opt_num == -1) || (path_num == 0)) err = -ECOMMAND;

	// for all the paths there are
	path = strtok(paths, " ");
	while(path){
	  err = i_mkdir(path, options, opt_num);
	  throw_error(err, "mkdir", path);
	  path = strtok(NULL, " ");
	}
      }


      else if(strcmp(com,"rmdir") == 0){
	// if command is in incorrect form
	if((opt_num == -1) || (path_num == 0)) err = -ECOMMAND;

	// for all the paths there are
	path = strtok(paths, " ");
	while(path){
	  err = i_rmdir(path);
	  
	  throw_error(err, "rmdir", path);

	  //if option '-p' and we got rid of the path easily
	  if((opt_num != 0) || (err != 0)){

	    char *dup = malloc(COM_LENGTH);
	    strcpy(dup, dirname(strdup(path)));

	    while(strcmp(dup, "/") != 0){
	      err = i_rmdir(dup);
	      
	      if(err != 0) {
		throw_error(err, "rmdir", dup);
		break;
	      }
	      else{
	      strcpy(dup, dirname(strdup(dup)));
	      
	      }
	    }

	  }

	  path = strtok(NULL, " ");
	}
      }
      else if(strcmp(com,"echo") == 0){
	
      }
      else {
	printf("Error: Command not recognized.\n");
      }

    //clean house
      free(paths); // should clean out path as well, because path = strtok(paths, ...)

    free(options);
    }


    err = 0;



    printf("%s user: ", workdir);
    // next command. bring it on!
    memset(command, 0, COM_LENGTH);
    fgets(command, COM_LENGTH, stdin);

  }
}




